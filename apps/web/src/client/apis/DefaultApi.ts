/* tslint:disable */
/* eslint-disable */
/**
 * Patient Voice API
 * Patient Voice service API description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Category,
  CreateCommentDto,
  CreatePostDto,
  CreateSubPostDto,
  GetNotificationsResponseDto,
  HasUnreadNotificationResponseDto,
  PostDetail,
  PostPreview,
  Question,
  ReadNotificationDto,
  SimpleUser,
  SubQuestionDto,
  UpdateFeedbackDto,
  UserCreate,
  UserProfile,
} from '../models/index';
import {
    CategoryFromJSON,
    CategoryToJSON,
    CreateCommentDtoFromJSON,
    CreateCommentDtoToJSON,
    CreatePostDtoFromJSON,
    CreatePostDtoToJSON,
    CreateSubPostDtoFromJSON,
    CreateSubPostDtoToJSON,
    GetNotificationsResponseDtoFromJSON,
    GetNotificationsResponseDtoToJSON,
    HasUnreadNotificationResponseDtoFromJSON,
    HasUnreadNotificationResponseDtoToJSON,
    PostDetailFromJSON,
    PostDetailToJSON,
    PostPreviewFromJSON,
    PostPreviewToJSON,
    QuestionFromJSON,
    QuestionToJSON,
    ReadNotificationDtoFromJSON,
    ReadNotificationDtoToJSON,
    SimpleUserFromJSON,
    SimpleUserToJSON,
    SubQuestionDtoFromJSON,
    SubQuestionDtoToJSON,
    UpdateFeedbackDtoFromJSON,
    UpdateFeedbackDtoToJSON,
    UserCreateFromJSON,
    UserCreateToJSON,
    UserProfileFromJSON,
    UserProfileToJSON,
} from '../models/index';

export interface CreateCommentRequest {
    createCommentDto: CreateCommentDto;
}

export interface CreatePostRequest {
    createPostDto: CreatePostDto;
}

export interface CreateSubPostRequest {
    createSubPostDto: CreateSubPostDto;
}

export interface CreateUserRequest {
    userCreate: UserCreate;
}

export interface GetCategoryRequest {
    id: string;
}

export interface GetNotificationsRequest {
    timestamp?: string;
    notificationId?: string;
}

export interface GetPostDetailsRequest {
    id: string;
}

export interface GetPostPreviewsRequest {
    id?: string;
    createdAt?: string;
}

export interface GetPostPreviewsInCategoryRequest {
    category: string;
    id?: string;
    createdAt?: string;
}

export interface MarkNotificationsAsReadRequest {
    readNotificationDto: ReadNotificationDto;
}

export interface SearchPostsRequest {
    query: string;
}

export interface UpdateCheerFeedbackRequest {
    postId: string;
    updateFeedbackDto: UpdateFeedbackDto;
}

export interface UpdateGoodFeedbackRequest {
    postId: string;
    updateFeedbackDto: UpdateFeedbackDto;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['createCommentDto'] == null) {
            throw new runtime.RequiredError(
                'createCommentDto',
                'Required parameter "createCommentDto" was null or undefined when calling createComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/comment`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCommentDtoToJSON(requestParameters['createCommentDto']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Create comment
     */
    async createComment(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new post
     */
    async createPostRaw(requestParameters: CreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['createPostDto'] == null) {
            throw new runtime.RequiredError(
                'createPostDto',
                'Required parameter "createPostDto" was null or undefined when calling createPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/post`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePostDtoToJSON(requestParameters['createPostDto']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Create a new post
     */
    async createPost(requestParameters: CreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new sub-post
     */
    async createSubPostRaw(requestParameters: CreateSubPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['createSubPostDto'] == null) {
            throw new runtime.RequiredError(
                'createSubPostDto',
                'Required parameter "createSubPostDto" was null or undefined when calling createSubPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/sub-post`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateSubPostDtoToJSON(requestParameters['createSubPostDto']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Create a new sub-post
     */
    async createSubPost(requestParameters: CreateSubPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createSubPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create user
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['userCreate'] == null) {
            throw new runtime.RequiredError(
                'userCreate',
                'Required parameter "userCreate" was null or undefined when calling createUser().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/user`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserCreateToJSON(requestParameters['userCreate']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Create user
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all categories
     */
    async getCategoriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Category>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     * Get all categories
     */
    async getCategories(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Category>> {
        const response = await this.getCategoriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get category by id
     */
    async getCategoryRaw(requestParameters: GetCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getCategory().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     * Get category by id
     */
    async getCategory(requestParameters: GetCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Category> {
        const response = await this.getCategoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user\'s posts
     */
    async getMyPostPreviewsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PostPreview>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/post/mypreviews`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PostPreviewFromJSON));
    }

    /**
     * Get user\'s posts
     */
    async getMyPostPreviews(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PostPreview>> {
        const response = await this.getMyPostPreviewsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get notifications with optional paging
     */
    async getNotificationsRaw(requestParameters: GetNotificationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNotificationsResponseDto>> {
        const queryParameters: any = {};

        if (requestParameters['timestamp'] != null) {
            queryParameters['timestamp'] = requestParameters['timestamp'];
        }

        if (requestParameters['notificationId'] != null) {
            queryParameters['notificationId'] = requestParameters['notificationId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/notifications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNotificationsResponseDtoFromJSON(jsonValue));
    }

    /**
     * Get notifications with optional paging
     */
    async getNotifications(requestParameters: GetNotificationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNotificationsResponseDto> {
        const response = await this.getNotificationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get post details
     */
    async getPostDetailsRaw(requestParameters: GetPostDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostDetail>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPostDetails().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/post/details/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostDetailFromJSON(jsonValue));
    }

    /**
     * Get post details
     */
    async getPostDetails(requestParameters: GetPostDetailsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostDetail> {
        const response = await this.getPostDetailsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all posts
     */
    async getPostPreviewsRaw(requestParameters: GetPostPreviewsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PostPreview>>> {
        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        if (requestParameters['createdAt'] != null) {
            queryParameters['createdAt'] = requestParameters['createdAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/post/previews`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PostPreviewFromJSON));
    }

    /**
     * Get all posts
     */
    async getPostPreviews(requestParameters: GetPostPreviewsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PostPreview>> {
        const response = await this.getPostPreviewsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all posts
     */
    async getPostPreviewsInCategoryRaw(requestParameters: GetPostPreviewsInCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PostPreview>>> {
        if (requestParameters['category'] == null) {
            throw new runtime.RequiredError(
                'category',
                'Required parameter "category" was null or undefined when calling getPostPreviewsInCategory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        if (requestParameters['createdAt'] != null) {
            queryParameters['createdAt'] = requestParameters['createdAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/post/previews/{category}`.replace(`{${"category"}}`, encodeURIComponent(String(requestParameters['category']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PostPreviewFromJSON));
    }

    /**
     * Get all posts
     */
    async getPostPreviewsInCategory(requestParameters: GetPostPreviewsInCategoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PostPreview>> {
        const response = await this.getPostPreviewsInCategoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user profile
     */
    async getProfileRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserProfile>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/user/profile`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserProfileFromJSON(jsonValue));
    }

    /**
     * Get user profile
     */
    async getProfile(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserProfile> {
        const response = await this.getProfileRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get all questions
     */
    async getQuestionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Question>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/question`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestionFromJSON));
    }

    /**
     * Get all questions
     */
    async getQuestions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Question>> {
        const response = await this.getQuestionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get all subQuestions
     */
    async getSubQuestionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SubQuestionDto>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/subQuestion`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubQuestionDtoFromJSON));
    }

    /**
     * Get all subQuestions
     */
    async getSubQuestions(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SubQuestionDto>> {
        const response = await this.getSubQuestionsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get user
     */
    async getUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimpleUser>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleUserFromJSON(jsonValue));
    }

    /**
     * Get user
     */
    async getUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimpleUser> {
        const response = await this.getUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * Check if user has unread notifications
     */
    async hasUnreadNotificationsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HasUnreadNotificationResponseDto>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/notifications/has-unread`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HasUnreadNotificationResponseDtoFromJSON(jsonValue));
    }

    /**
     * Check if user has unread notifications
     */
    async hasUnreadNotifications(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HasUnreadNotificationResponseDto> {
        const response = await this.hasUnreadNotificationsRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async healthControllerHealthCheckRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async healthControllerHealthCheck(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.healthControllerHealthCheckRaw(initOverrides);
    }

    /**
     * Mark notifications as read
     */
    async markNotificationsAsReadRaw(requestParameters: MarkNotificationsAsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['readNotificationDto'] == null) {
            throw new runtime.RequiredError(
                'readNotificationDto',
                'Required parameter "readNotificationDto" was null or undefined when calling markNotificationsAsRead().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/notifications/read`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReadNotificationDtoToJSON(requestParameters['readNotificationDto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Mark notifications as read
     */
    async markNotificationsAsRead(requestParameters: MarkNotificationsAsReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.markNotificationsAsReadRaw(requestParameters, initOverrides);
    }

    /**
     * Search posts
     */
    async searchPostsRaw(requestParameters: SearchPostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PostPreview>>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling searchPosts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/iapi/v1/post/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PostPreviewFromJSON));
    }

    /**
     * Search posts
     */
    async searchPosts(requestParameters: SearchPostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PostPreview>> {
        const response = await this.searchPostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Change cheer feedback
     */
    async updateCheerFeedbackRaw(requestParameters: UpdateCheerFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['postId'] == null) {
            throw new runtime.RequiredError(
                'postId',
                'Required parameter "postId" was null or undefined when calling updateCheerFeedback().'
            );
        }

        if (requestParameters['updateFeedbackDto'] == null) {
            throw new runtime.RequiredError(
                'updateFeedbackDto',
                'Required parameter "updateFeedbackDto" was null or undefined when calling updateCheerFeedback().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/feedback/cheer/{postId}`.replace(`{${"postId"}}`, encodeURIComponent(String(requestParameters['postId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFeedbackDtoToJSON(requestParameters['updateFeedbackDto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change cheer feedback
     */
    async updateCheerFeedback(requestParameters: UpdateCheerFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateCheerFeedbackRaw(requestParameters, initOverrides);
    }

    /**
     * Change good feedback
     */
    async updateGoodFeedbackRaw(requestParameters: UpdateGoodFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['postId'] == null) {
            throw new runtime.RequiredError(
                'postId',
                'Required parameter "postId" was null or undefined when calling updateGoodFeedback().'
            );
        }

        if (requestParameters['updateFeedbackDto'] == null) {
            throw new runtime.RequiredError(
                'updateFeedbackDto',
                'Required parameter "updateFeedbackDto" was null or undefined when calling updateGoodFeedback().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("access-token", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/iapi/v1/feedback/good/{postId}`.replace(`{${"postId"}}`, encodeURIComponent(String(requestParameters['postId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateFeedbackDtoToJSON(requestParameters['updateFeedbackDto']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Change good feedback
     */
    async updateGoodFeedback(requestParameters: UpdateGoodFeedbackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateGoodFeedbackRaw(requestParameters, initOverrides);
    }

}
